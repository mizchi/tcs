{
  global.ctx = {}
  ctx.indentStack = []
  ctx.indent = ""
}

start = program
program = lines:line* { type: 'program', body: lines}

line = SAMEDENT node:statement __blank {node}

statement =
  forStatement / ifStatement / element / comment / code / multilineCode / text / expr

//////////////////
// Statements
//////////////////

ifStatement = 'if' __ condition:toTheEndOfLine children:block {
  type: 'if'
  condition: {type: 'free', value: condition}
  body: children
}

forStatement = 'for' __ left:identifier __ "in" __ right:toTheEndOfLine children:block {
  type: 'for'
  left: left
  right: {type: 'free', value: right}
  body: children
}

text = '|' _ text:toTheEndOfLine {type: 'text', value: text}

element = s:assignable props:props? _ styles:styles? _ children: _elementChildren?
  {
    {type: 'element', value: s, children, props, styles}
  }
  _elementChildren
    = EOL INDENT c:line* DEDENT { c }
    / !EOL _ !'=' _ text:toTheEndOfLine {{type: 'inlineText', value: text}}
    / !EOL _ '=' _ expr: expr {expr}
  assignable
    =
      elementName: symbol modifiers:modifier*
      {
        type: 'element'
        elementType: elementName
        modifiers: modifiers
      }
    /
      modifiers:modifier+
      {
        type: 'element'
        elementType: 'div'
        modifiers: modifiers
      }
  modifier = className / id / ref
  className = '.' className:symbol {type: 'className', value:className}
  id = '#' id:symbol {type: 'id', value: id}
  ref = '&' ref:symbol {type: 'ref', value: ref}

  props = "(" __blank props:(p:property __blank {p})* ")"
    {
      type: 'props'
      children: props
    }

  styles = "{" __blank props:(p:property __blank {p})* "}"
    {
      type: 'styles'
      children: props
    }
  property
    = key:symbol __blank '=' __blank expr: expr
      {
        type: 'property'
        key: key
        expr: expr
      }
    / '>' _ key:dottableSymbol {
      {
        type: 'mergeable-object'
        key: key
      }
    }

comment = '//' value:toTheEndOfLine
  {
    {type: 'comment', value}
  }

code = ('-' / '`') space+ value:toTheEndOfLine
  {
    {type: 'code', value}
  }

_multilineCodeLeader = '```'
multilineCode = _multilineCodeLeader EOL code:$((!_multilineCodeLeader .)*) _multilineCodeLeader
  {
    {type: 'multilineCode', value:code}
  }

//////////////
// Expressions
//////////////

expr = value / embededCode
value = boolean / number / string / memberAccessableIdentifier
boolean = bool:bool {type: 'boolean', value: bool}

identifier = symbol:symbol {type: 'identifier', value: symbol}
memberAccessableIdentifier = symbol:dottableSymbol {type: 'identifier', value: symbol}
string
  = "\"" value: symbol "\"" {type: 'string', value: value}
  / "\'" value: symbol "\'" {type: 'string', value: value}

number = digits:digits {type: 'number', value: digits}
embededCode
  = '{-' code:$((!'-}' .)*) '-}' {type: 'embededCode', value: code}
  / '{' code:$((!'}' .)*) '}' {type: 'embededCode', value: code}

// Syntax

SAMEDENT
  = i:[ \t]* &{
    i.join('') is ctx.indent
  }

INDENT
  = &(
      i:[ \t]+ &{
        i.length > ctx.indent.length
      }
      {
        ctx.indentStack.push(ctx.indent)
        ctx.indent = i.join("")
      }
    )

DEDENT
  = {
    ctx.indent = ctx.indentStack.pop()
  }


// Token

space = ' '
_ = space*
__ = space+
__blank = $([ \n\t\r]*)

EOL = "\r\n" / "\n" / "\r"

toTheEndOfLine = text:$((!EOL .)+) EOL {text}
block = children: ( INDENT c:line* DEDENT { c }) {children}

symbol = $([a-zA-Z_] [a-zA-Z\d_]*)
dottableSymbol = $(symbol ('.' symbol)*)
hyphenizableSymbol = $([a-zA-Z_-] [a-zA-Z\d_-]*)

digits = n:$( ('+'/'-')? [1-9] [0-9]*) { parseInt(n, 10)}
bool = "true" / "false"
