{
  global.ctx = {}
  ctx.indentStack = []
  ctx.indent = ""
}

start = program
program = lines:line* { type: 'program', body: lines}

line = SAMEDENT node:(
  forStatement / ifStatement / element / comment / code / multilineCode / text
  ) EOL? {node}

element = s:assignable props:props? styles:styles? children: _elementChildren?
  {
    {type: 'element', value: s, children, props, styles}
  }
  _elementChildren
    = EOL INDENT c:line* DEDENT { c }
    / _* !'=' _* text:toTheEndOfLine {{type: 'inlineText', value: text}}
    / _* '=' _* expr: expr {expr}
  assignable
    =
      elementName: symbol modifiers:modifier*
      {
        type: 'element'
        elementType: elementName
        modifiers: modifiers
      }
    /
      modifiers:modifier+
      {
        type: 'element'
        elementType: 'div'
        modifiers: modifiers
      }
  modifier = className / id / ref
  className = '.' className:symbol {type: 'className', value:className}
  id = '#' id:symbol {type: 'id', value: id}
  ref = '&' ref:symbol {type: 'ref', value: ref}

  props = "(" __ props:(p:property __ {p})* ")"
    {
      type: 'props'
      children: props
    }

  styles = "{" __ props:(p:property __ {p})* "}"
    {
      type: 'styles'
      children: props
    }
  property = key:symbol __ '=' __ expr: expr
    {
      type: 'property'
      key: key
      expr: expr
    }

embededCode
  = '{-' code:$((!'-}' .)*) '-}' {type: 'embededCode', value: code}
  / '{' code:$((!'}' .)*) '}' {type: 'embededCode', value: code}

text = '|' _* text:toTheEndOfLine {type: 'text', value: text}

toTheEndOfLine = text:$((!EOL .)+) EOL {text}

block = children: ( INDENT c:line* DEDENT { c }) {children}

// TODO: fix statement
ifStatement = 'if' _+ condition:toTheEndOfLine children:block {
  type: 'if'
  condition: {type: 'free', value: condition}
  body: children
}

forStatement = 'for' _+ left:identifier _+ "in" _+ right:toTheEndOfLine children:block {
  type: 'for'
  left: left
  right: {type: 'free', value: right}
  body: children
}

expr = value

symbol = $([a-zA-Z] [a-zA-Z\d]*)
value = boolean / number / string / identifier / embededCode

boolean = bool:bool {type: 'boolean', value: bool}
bool = "true" / "false"
identifier = symbol:symbol {type: 'identifier', value: symbol}
string
  = "\"" value: symbol "\"" {type: 'string', value: value}
  / "\'" value: symbol "\'" {type: 'string', value: value}
number = digits:digits {type: 'number', value: digits}
digits = n:$( ('+'/'-')? [1-9] [0-9]*) { parseInt(n, 10)}

_ = [ \n\t\r]
__ = _*

comment = '//' value:toTheEndOfLine
  {
    {type: 'comment', value}
  }

code = '-' _+ value: $((!'\n' .)*)
  {
    {type: 'code', value}
  }

_multilineCodeLeader = '```'
multilineCode = _multilineCodeLeader EOL code:$((!_multilineCodeLeader .)*) _multilineCodeLeader
  {
    {type: 'multilineCode', value:code}
  }

EOL = "\r\n" / "\n" / "\r"

SAMEDENT
  = i:[ \t]* &{
    i.join('') is ctx.indent
  }

INDENT
  = &(
      i:[ \t]+ &{
        i.length > ctx.indent.length
      }
      {
        ctx.indentStack.push(ctx.indent)
        ctx.indent = i.join("")
      }
    )

DEDENT
  = {
    ctx.indent = ctx.indentStack.pop()
  }
