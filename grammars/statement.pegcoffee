//////////////////
// Statements
//////////////////
topLevelStatement
  = statement

statement
  = variableDeclaration
  / classDeclaration
  / interfaceDeclaration
  / declareVariable
  / funcDeclaration
  / forInStatement
  / forOfStatement
  / ifStatement
  / exprStatement
  / returnStatement
  // debugger
  // continue
  // break
  // throw
  // try

exprStatement = e: expr {
  {type: 'ExpressionStatement', expression: e}
}

declarationKind = $("let" / "var" / "const")
variableDeclaration = kind:declarationKind __ ident:identifierWithTypeAnnotation _ "=" _ e:expr {
  type: 'VariableDeclaration'
  declarations: [{
    type: 'VariableDeclarator'
    id: ident
    init: e
  }]
  kind: kind
}

funcParamList = h:funcParam rest:(_ "," _ p:funcParam {p})* {[h].concat(rest)}
funcParam = identifierWithTypeAnnotation
funcDeclaration = id:identifier "(" _ params:funcParamList? _ ")" _ returnType:typeAnnotation? _ EOL body:block
  {
    type: 'FunctionDeclaration'
    id: id
    params: params ? []
    defaults: []
    returnType: returnType
    body:
      type: 'BlockStatement'
      body: wrapBody(body)
    rest: null
    generator: false
    expression: true
  }


methodKind = $("get" / "set")
methodDefinition =
  _static:"static "? kind:(m:methodKind __ {m})?
  id:identifier "(" _ params:funcParamList? _ ")" _ returnType:typeAnnotation? _ EOL body:block
  {
    type: 'MethodDefinition'
    key: id
    kind: kind ? ""
    static: _static?
    value:
      type: 'FunctionExpression'
      id: null
      params: params ? []
      defaults: []
      returnType: returnType
      body:
        type: 'BlockStatement'
        body: wrapBody(body)
      rest: null
      generator: false
      expression: true
  }

classProperty =
  id:identifier _ ann:typeAnnotation {
    type: 'ClassProperty'
    key: id
    typeAnnotation: ann
  }

inclassStatement = methodDefinition / classProperty

lineInClass
  = SAMEDENT node:(!EOL s:inclassStatement {s}) comment? EOL* {node}

classBody = INDENT lines:lineInClass+ DEDENT {
  type: 'ClassBody'
  body: lines
}

classDeclaration =
  "class" __ id:identifier
  superClass:( __ "extends" __ e:expr {e})?
  body:(_ EOL b:classBody {b})?
  {
    type: 'ClassDeclaration'
    id: id
    superClass: superClass
    body:body ? {type: 'ClassBody', body: []}
    typeParameters: undefined
    implements: undefined
  }

returnStatement = 'return' expr:(__ e:expr {e})? {
  type: 'ReturnStatement'
  argument: expr
}

ifStatement = 'if' __ test:expr _ EOL body:block elseIfs:_elseIf* _else:_else?
  {
    alternate =
      elseIfs.reverse().reduce (prev, next) ->
        type: 'IfStatement'
        test: next.test
        consequent:
          type: 'BlockStatement'
          body: next.body
        alternate: prev
      , (
        if _else?
          type: 'BlockStatement'
          body: _else
        else
          null
      )
    type: 'IfStatement'
    test: test
    consequent:
      type: 'BlockStatement'
      body: body
    alternate: alternate
  }
  _elseIf = SAMEDENT 'else' __ 'if' __ test:expr _ EOL body:block
    {
      test: test
      body: body
    }
  _else = SAMEDENT 'else' _ EOL body:block {
    body
  }

forInitKind = $('var' / 'let')
forInStatement =
  'for' kind:(__ k:forInitKind {k})?
  __ left:identifier
  __ "in"
  __ right:expr _ EOL body:block
  {
    type: 'ForInStatement'
    left:
      type: 'VariableDeclaration'
      kind: kind ? 'var'
      declarations: [{
        type: 'VariableDeclarator'
        id: left
      }]
    right: right
    body:
      type: 'BlockStatement'
      body: body
  }

forOfStatement =
  'for' kind:(__ k:forInitKind {k})?
  __ left:identifier
  __ "of"
  __ right:expr _ EOL body:block
  {
    type: 'ForOfStatement'
    left:
      type: 'VariableDeclaration'
      kind: kind ? 'var'
      declarations: [{
        type: 'VariableDeclarator'
        id: left
      }]
    right: right
    body:
      type: 'BlockStatement'
      body: body
  }
importDeclaration =
  "import" __ id:identifier __ "from" __ s:string
  {
    type: "ImportDeclaration"
  }

typeDeclaration = symbol:symbol _ ':' _ expr:_propTypeExpr
  {__rp type: 'typeDeclaration', propertyName:symbol, typeExpr: expr}
  _propTypeExpr = typeName:$(symbol) + isArray:'[]'? optional:'?'?
    {__rp type: 'typeExpr', typeName:typeName, isArray: isArray?, optional: optional?}
