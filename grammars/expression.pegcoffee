//////////////
// Expressions
//////////////

expr = additive
additive =
  left:multiplicative _ op:_additiveOperator _ right:additive {
    type: 'BinaryExpression'
    left: left
    operator: op
    right: right
  }
  / multiplicative
  _additiveOperator = $("+" !"=" / "-" !"=" )

multiplicative =
  left:primary _ op:_multicativeOperator _ right:multiplicative {
    type: 'BinaryExpression'
    left: left
    operator: op
    right: right
  }
  / primary
  _multicativeOperator = $("*" !"=" / "/" !"=" )

primary
  = arrowFuncExpr
  / objectExpr
  / callExpr
  / assignmentExpr
  / memberExpr
  / arrayExpr
  / identifier
  / literal
  / "(" _ e:expr _ ")" {e}

callExpr = callee:memberExpr "(" _ args:_callArguments? _ ")"
  {
    type: "CallExpression"
    callee: callee
    arguments: args ? []
  }

  _callArguments = first:expr rest:(_ ',' _ e:expr {e})* {
    return [first].concat(rest)
  }

memberExpr = first:_memberLeftHandSideExpr accesses:_memberAccess*
  {
    accesses.reduce (node, access) ->
      type: 'MemberExpression'
      computed: false
      object: node
      property: access
    , first
  }

  _memberLeftHandSideExpr = identifier // callExpr
  _memberAccess
    = '.' id:identifier {
      id
    }
  // dynamic member access
identifier = !reserved name:symbol{
  type: 'Identifier', name:name
}

identifierWithTypeAnnotation = !reserved name:symbol ann:typeAnnotation? {
  type: 'Identifier', name:name, typeAnnotation: ann
}

assignmentExpr = left:_assignable _ op:_assignmentOp _ right:expr
  {
    type: 'AssignmentExpression'
    left: left
    operator: op
    right: right
  }
  _assignmentOp = $("=" / "+=" / "-=" / '*=' / '/=')
  _assignable = memberExpr

objectKey = identifier / literal
property
  = key:objectKey _ ':' _ expr:expr
    {
      type: 'Property'
      key: key
      value: expr
      kind: 'init'
      method: false
      shorthand: false
      computed: false
    }

objectExpr =
  "{" _ EOL? _ properties:(head:property rest:(_ (',' / EOL) _ EOL? _ p:property {p})* {[head].concat(rest)})? _ EOL? _ "}"
  {
    type: 'ObjectExpression'
    properties: properties ? []
  }


arrowFuncParamList = h:arrowFuncParam rest:(_ "," _ p:arrowFuncParam {p})* {[h].concat(rest)}
arrowFuncParam = identifier

arrowFuncExpr
  = "(" _ params:arrowFuncParamList? _ ")" _ "=>" _ expr:expr
    {
      type: "ArrowFunctionExpression"
      id: null
      params: params ? []
      defaults: []
      body: expr
      rest: null
      generator: false
      expression: true
    }
  / "(" _ params:arrowFuncParamList? _ ")" _ "=>" _ EOL body:block
    {
      type: "ArrowFunctionExpression"
      id: null
      params: params ? []
      defaults: []
      body:
        type: 'BlockStatement'
        body: wrapBody(body)
      rest: null
      generator: false
      expression: false
    }

arrayExpr = '[' _ exprs:(first:expr rest:(_ "," _ e:expr {e})* {[first].concat(rest)})? _ ']'
  {
    type: 'ArrayExpression'
    elements: exprs ? []
  }
